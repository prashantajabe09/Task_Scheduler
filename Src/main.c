/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "defines.h"
#include "system.h"

uint8_t current_task = 0;
uint32_t psp_of_tasks[MAX_TASKS] = {TASK1_STACK_START,TASK2_STACK_START};
uint32_t task_handler_addr[MAX_TASKS];


void Task1_Handler(void);
void Task2_Handler(void);
void switch_msp_to_psp(void);
void init_scheduler_stack(uint32_t scheduler_stack_start);
void init_task_stack(void);

int main(void)
{
	task_handler_addr[0] = (uint32_t)Task1_Handler;
	task_handler_addr[1] = (uint32_t)Task2_Handler;

	init_scheduler_stack(SHCEDULER_STACK_START);
	init_task_stack();
	switch_msp_to_psp();
	systick_init();
	Task1_Handler();
    /* Loop forever */
	for(;;);
}

void Task1_Handler(void)
{
	while(1)
	{
		printf("Task1!");
	}
}
void Task2_Handler(void)
{
	while(1)
	{
		printf("Task1!");
	}
}

__attribute__((naked)) void init_scheduler_stack(uint32_t scheduler_stack_start)
{
	__asm volatile("MSR MSP, %0"::"r"(scheduler_stack_start): );
	__asm volatile("BX LR");
}

void init_task_stack(void)
{
	uint32_t* p_PSP;
	for (uint8_t i = 0; i < MAX_TASKS;i++)
	{
		p_PSP = (uint32_t*)psp_of_tasks[i];

		p_PSP--; // because ARM stack is full descending;
		*p_PSP = DUMMY_XPSR;

		p_PSP--;
		*p_PSP = task_handler_addr[i];

		p_PSP--;
		*p_PSP = 0xFFFFFFFD;

		for (uint8_t j = 0; j < 13; j++)
		{
			p_PSP--;
			*p_PSP = 0x00;
		}

		psp_of_tasks[i] = (uint32_t)p_PSP;
	}
}

uint32_t get_psp_value(void)
{
	return psp_of_tasks[current_task];
}

void save_psp_value(uint32_t psp_value)
{
	psp_of_tasks[current_task] = psp_value;
}
__attribute__((naked)) void switch_msp_to_psp(void)
{
	__asm volatile("PUSH {LR}");
	 __asm volatile("BL get_psp_value"); // get current tasks psp value
	 __asm volatile("POP {LR}");
	 __asm volatile("MSR PSP,R0"); // assign current tasks psp to PSP
	 __asm volatile("MOV R0,#0x02");
	 __asm volatile("MSR CONTROL,R0"); // change sp from MSP to PSP
	 __asm volatile("BX LR");

}

void get_next_task(void)
{
	current_task++;
	current_task %= MAX_TASKS;
}
